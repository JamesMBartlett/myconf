call plug#begin()

function! BuildYCM(info)
  " info is a dictionary with 3 fields
  " - name:   name of the plugin
  " - status: 'installed', 'updated', or 'unchanged'
  " - force:  set on PlugInstall! or PlugUpdate!
  if a:info.status == 'installed' || a:info.force
    !./install.py --all
  endif
endfunction

Plug 'ycm-core/YouCompleteMe', { 'do': function('BuildYCM') }

Plug 'morhetz/gruvbox'
Plug 'preservim/nerdtree'
Plug 'vim-autoformat/vim-autoformat'
Plug 'KarimElghamry/vim-auto-comment'
Plug 'preservim/vimux'
Plug 'christoomey/vim-tmux-navigator'
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'yegappan/mru'
Plug 'dhruvasagar/vim-zoom'

" Initialize plugin system.
call plug#end()

autocmd vimenter * ++nested colorscheme gruvbox

" Set leader to space
nnoremap <space> <Nop>
let mapleader = " "

" YCM Commands
let g:ycm_autoclose_preview_window_after_insertion = 1
nnoremap <leader>gt :YcmCompleter GoTo<CR>
nnoremap <leader>gu :YcmCompleter GoToReferences<CR>
nnoremap <leader>gi :YcmCompleter GoToImplementation<CR>
nnoremap <leader>gd :YcmCompleter GoToDeclaration<CR>
nnoremap <leader>t :YcmCompleter GetType<CR>
nnoremap <expr> <leader>r ":YcmCompleter RefactorRename " . input("New name: ") . "<CR>"

" NerdTree
function! NerdTreeToggleWCtx()
  if bufname('%') =~ 'NERD_tree_\d\+'
    execute ":NERDTreeToggle"
  else
    execute ":NERDTreeFind"
  endif
endfunction
nnoremap <leader>n :call NerdTreeToggleWCtx()<CR>
" Close the tab if NERDTree is the only window remaining in it.
autocmd BufEnter * if winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif
" If another buffer tries to replace NERDTree, put it in the other window, and bring back NERDTree.
autocmd BufEnter * if bufname('#') =~ 'NERD_tree_\d\+' && bufname('%') !~ 'NERD_tree_\d\+' && winnr('$') > 1 |
      \ let buf=bufnr() | buffer# | execute "normal! \<C-W>w" | execute 'buffer'.buf | endif

" fzf.vim
let g:fzf_command_prefix = 'Fzf'
nnoremap <leader>tt :FzfFiles<CR>
function! RipgrepFzf(query, fullscreen)
  let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case -- %s || true'
  let initial_command = printf(command_fmt, shellescape(a:query))
  let reload_command = printf(command_fmt, '{q}')
  let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
  call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
endfunction

command! -nargs=* -bang FzfRG call RipgrepFzf(<q-args>, <bang>0)
nnoremap <leader>tf :FzfRG<CR>

" mru fzf
command! FzfMru call fzf#run(fzf#wrap({'source': MruGetFiles()}))
nnoremap <leader>to :FzfMru<CR>

" vim-autoformat
let g:autoformat_autoindent = 0
let g:autoformat_retab = 0
let g:formatdef_buildifier='"buildifier --lint=fix"'
nnoremap <leader>f :Autoformat<CR>

" vim-auto-comment
let g:autocomment_map_keys=0
let g:inline_comment_dict = {
      \'//': ['cpp', 'c', 'cc', 'h', 'hpp', 'js', 'ts', 'jsx', 'tsx'],
      \'#': ['py', 'sh', 'bazel', 'bzl'],
      \'"': ['vim'],
      \}
nnoremap <C-/> :AutoInlineComment<CR>

" vimux
nnoremap <leader>cp :VimuxPromptCommand<CR>
nnoremap <leader>cl :VimuxRunLastCommand<CR>
nnoremap <leader>ci :VimuxInspectRunner<CR>
nnoremap <leader>cz :VimuxZoomRunner<CR>
nnoremap <leader>co :VimuxOpenRunner<CR>
" Write all buffers before navigating from Vim to tmux pane
let g:tmux_navigator_save_on_switch = 2

" Visual Settings
set background=dark
set number

"Default tab settings
set tabstop=2
set shiftwidth=2
set expandtab

" Misc settings
nnoremap <leader>v "+p
vnoremap <leader>x "+y
set noswapfile
set autowrite
" Return to last edit position when opening files (You want this!)
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif

filetype plugin on
